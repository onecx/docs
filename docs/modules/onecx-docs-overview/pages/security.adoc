:idprefix:
:idseparator: -
:imagesdir: ../images

[#security-guidelines]
= OneCX Security Guidelines

== Purpose

This document defines practical, OneCX‑aligned security guidelines for engineering, operations, and documentation. It consolidates baseline expectations and best practices to reduce risk across our microfrontend apps, backend services, and supporting tooling.


== Scope and Audience

- Applies to all OneCX repositories, microfrontends, backends, CI/CD pipelines, and environments.
- Intended for developers, maintainers, DevOps engineers, SRE, and technical writers.


== Security Principles

- Least privilege: Minimize access, scope, and lifetime for identities and tokens.
- Defense in depth: Layered controls across client, API, data, and infrastructure.
- Secure by default: Prefer safe defaults and opt‑in for risky capabilities.
- Shift left: Catch issues early with automation in CI and pre‑commit checks.
- Observability and response: Log, monitor, alert, and respond to incidents quickly.


== Secure Development Lifecycle

- Threat modeling: For new features and architectural changes, identify assets, trust boundaries, and abuse cases; document decisions (e.g. ADRs).
- Code review: Enforce security‑aware reviews; verify input validation, authZ checks, and error handling.
- Static analysis: Enable linters and SAST where available; fix or triage findings.
- Dependency hygiene: Pin versions; use advisories and scanners; update regularly.
- Secrets scanning: Enable secret scanners; block commits with hard‑coded credentials.
- Build reproducibility: Prefer deterministic builds and integrity checks for artifacts.


== Secrets Management

- Never commit secrets: API keys, tokens, passwords, certificates must not appear in repositories, issues, or logs.
- Use secret vaults: Store and inject secrets via the platform’s secret manager or CI/CD vaults; rotate regularly.
- Principle of least use: Scope tokens to the minimal permissions and tenants; set short TTL; use refreshable flows.
- Local development: Use `.env` files only with non‑production credentials; exclude via `.gitignore`.


== Dependency and Supply Chain Security

- Lockfiles: Commit lockfiles where applicable; review diffs for transitive changes.
- Vulnerability scans: Run `npm audit`/`yarn npm audit`, `OWASP Dependency-Check`, or equivalent during CI; fail on high/critical unless justified.
- Trusted sources: Use official registries; avoid arbitrary Git URLs for production dependencies.
- Integrity: Verify checksums/signatures for downloaded tools and binaries in CI.


== Authentication and Authorization

- Centralized IAM: Rely on the platform’s IAM for identity, SSO/OIDC flows, and RBAC.
- Token handling: Use short‑lived tokens; prefer `Authorization: Bearer` over custom headers; never log tokens.
- Client storage: Avoid `localStorage` for sensitive tokens; prefer `httpOnly`, `secure`, `SameSite=strict` cookies when feasible.
- Role and permission checks: Enforce on the backend; mirror non‑authoritative checks on the UI for UX only.


== Multi‑Tenancy and Data Segregation

- Tenant context: Propagate and validate tenant identifiers on every request boundary.
- Access control: Combine tenant checks with RBAC; never infer tenant from UI state alone.
- Data isolation: Avoid cross‑tenant joins unless explicitly designed and reviewed; prefer per‑tenant partitions or filters.


== Data Protection and Privacy

- Data minimization: Collect and process only what is necessary for the feature.
- Classification: Tag data sensitivity and apply handling rules (masking, encryption, retention).
- Encryption: Use TLS in transit; encrypt sensitive data at rest using platform‑approved mechanisms.
- Logs and PII: Do not log secrets or full PII; mask or hash identifiers where logging is required.


== Frontend Security (Microfrontends)

- Content Security Policy (CSP): Define restrictive CSP; disallow inline scripts/styles; permit only trusted origins.
- DOM and template safety: Avoid `innerHTML` and unsafe bindings; sanitize user‑supplied content.
- XSS/Clickjacking: Use `X-Frame-Options`/`frame-ancestors`, `X-Content-Type-Options`, and `Referrer-Policy` via the shell/reverse proxy.
- CORS: Limit origins, methods, and headers; do not use `*` for authenticated endpoints.
- Browser storage: Store only non‑sensitive data in `localStorage`/`sessionStorage`; clear on logout and tenant switch.
- Third‑party scripts: Vet libraries, pin versions, and load from trusted CDNs or self‑host.


== API and Backend Security

- Input validation: Validate and normalize all inputs server‑side; reject on schema violations.
- Output encoding: Encode responses to prevent injection in consuming clients.
- Rate limiting and quotas: Apply per user/client/tenant to mitigate abuse.
- Error handling: Return generic messages; avoid stack traces and internal IDs in responses.
- SSRF and deserialization: Avoid dynamic URL fetches; whitelist outbound hosts; use safe serializers.


== CI/CD and Infrastructure

- Least‑privilege runners: Restrict CI tokens and permissions; separate build and deploy roles.
- Environment separation: Use distinct credentials and configs for dev/test/stage/prod; prohibit promotion of data across boundaries without approval.
- Artifact integrity: Sign artifacts or use checksums; verify on deploy.
- Image hardening: Use minimal base images; apply updates; run as non‑root; drop Linux capabilities.
- Network controls: Segment services; restrict ingress/egress; prefer mutual TLS for service‑to‑service calls.


== Logging, Monitoring, and Incident Response

- Structured logs: Emit machine‑readable logs with correlation/tenant IDs; avoid sensitive fields.
- Metrics and alerts: Track auth failures, rate‑limit triggers, CSP violations, and error spikes; define actionable alerts.
- Audit trails: Record security‑relevant actions (login, privilege changes, config edits) with actor, time, tenant.
- Incident playbooks: Establish triage, containment, eradication, and post‑incident review procedures; practice regularly.


== Vulnerability Reporting and Handling

- Responsible disclosure: Provide a clear way to report vulnerabilities (private channel preferred); acknowledge promptly.
- Triage: Classify severity and impact; define a remediation owner and timeline.
- Patching: Prioritize critical/high issues; backport fixes where necessary; track to closure.
- Communication: Coordinate announcements for user‑visible risks following organizational policy.


== Documentation and Configuration

- Security notes: Document security‑relevant defaults, flags, and required headers for each service/app.
- Sample configs: Provide safe defaults in examples; highlight production‑only hardening options.
- Change history: Record security‑impacting changes (auth flows, CSP updates, permission models).


== Quick Checklist (Non‑Exhaustive)

- No secrets in code, issues, or logs; scanners enabled.
- Dependencies updated; no unreviewed high/critical advisories.
- Strict CSP and CORS; no inline scripts; trusted origins only.
- Backend enforces authZ per tenant and role; UI checks are non‑authoritative.
- Inputs validated server‑side; errors sanitized; logs structured with minimal PII.
- CI/CD uses least privilege; artifacts verified; images hardened.
- Monitoring and alerts in place; incident process defined and tested.


== References

- OWASP Top 10 (Web, API, and Mobile)
- OWASP ASVS and MASVS
- NIST SSDF (Secure Software Development Framework)
- Supply‑chain security: SLSA Framework, Sigstore

